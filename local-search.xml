<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GRE - quantitative reasoning</title>
    <link href="/2022/05/09/quant/"/>
    <url>/2022/05/09/quant/</url>
    
    <content type="html"><![CDATA[<h1 id="quantitave-reasoning">QUANTITAVE REASONING</h1><h2 id="arithmetic">Arithmetic</h2><h3 id="整数-integers">1.1 整数 integers</h3><ol type="1"><li><p>concepts</p><ul><li><p>因数（factor）/ 因子（divisor）倍数（multiple）</p></li><li><p>最小公倍数least common multiple、最大公因数great common divisor/factor</p></li><li><p>商quotient 余数remainder</p></li><li><p>A is divided by B &amp;&amp; A is divisible by B，后者表示能除尽，前者不一定</p></li><li><p>奇数odd 偶数even</p></li><li><p>质数prime 合数composite</p></li><li><p>有理数rational numbers</p></li><li><p>完全平方数perfect 完全立方数square perfect cube</p></li><li><p>连续整数consecutive integers</p></li></ul></li><li><p>properties</p><p><strong>奇偶性</strong></p><table><thead><tr class="header"><th style="text-align: center;">相加减个数</th><th style="text-align: center;">odd/even</th><th style="text-align: center;">结果</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">奇数个</td><td style="text-align: center;">奇</td><td style="text-align: center;">奇</td></tr><tr class="even"><td style="text-align: center;">偶</td><td style="text-align: center;">奇</td><td style="text-align: center;">奇</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">奇偶都有</td><td style="text-align: center;">奇数</td></tr><tr class="even"><td style="text-align: center;"><strong>偶</strong></td><td style="text-align: center;"><strong>偶</strong></td><td style="text-align: center;"><strong>偶</strong></td></tr></tbody></table><ul><li><span class="math inline">\(\prod^{n}{Ni}\)</span> 结果为奇，Ni全为奇</li><li><span class="math inline">\(\prod^{n}{Ni}\)</span>结果为偶，Ni中至少有一个偶</li><li><span class="math inline">\(\sum^{n}{Ni}=0\)</span> ，Ni为连续整数，则n为奇</li><li><span class="math inline">\(\sum^{n}{Ni}=0\)</span>，Ni为连续奇数，则n为偶</li><li><span class="math inline">\(\sum^{n}{Ni}=0\)</span>，Ni为连续偶数，则n为奇</li></ul><p><strong>factor and multiple 约数和倍数</strong></p><ul><li>a为质数，n为非负整数，则<span class="math inline">\({a^n}\)</span> 的因子有n+1个，包括1和本身</li></ul><p><strong>平方数</strong></p><ul><li>偶平方数能被4整除</li><li>奇平方数可写作8k+1</li></ul><p><strong>因子 factor</strong></p><ul><li>因子数的求法：将n分解为质因子相乘的形式，<span class="math inline">\({n=a^x*b^y*c^z}\)</span> ，则因子数<span class="math inline">\(=(x+1)(y+1)(z+1)\)</span></li><li>自然数n不是完全平方数，则n的因子中小于<span class="math inline">\(\sqrt{n}\)</span>的占一半，大于<span class="math inline">\(\sqrt{n}\)</span>的占一半</li><li>自然数n是完全平方数，则<span class="math inline">\(\sqrt{n}\)</span> 也为一个因子，并且除此之外，小于<span class="math inline">\(\sqrt{n}\)</span>的占一半，大于<span class="math inline">\(\sqrt{n}\)</span>的占一半</li><li>推论：若一个自然数有奇数个因子，则其必为完全平方数</li></ul></li></ol><h3 id="分数-fraction">1.2 分数 fraction</h3><ul><li><p>分子numerator 分母denominator</p></li><li><p>倒数reciprocal</p></li><li><p>带分数mixed fraction</p></li><li><p>真分数proper fraction，假分数improper</p></li></ul><h3 id="小数-decimals">1.3 小数 decimals</h3><table><thead><tr class="header"><th style="text-align: center;">数位digit</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">千位</td><td style="text-align: center;">thousands digit</td></tr><tr class="even"><td style="text-align: center;">百位</td><td style="text-align: center;">hundreds</td></tr><tr class="odd"><td style="text-align: center;">十位</td><td style="text-align: center;">tens</td></tr><tr class="even"><td style="text-align: center;"><strong>个位</strong></td><td style="text-align: center;"><strong>one or units</strong></td></tr><tr class="odd"><td style="text-align: center;">十分位</td><td style="text-align: center;">ten<strong>th</strong>s</td></tr><tr class="even"><td style="text-align: center;">百分位</td><td style="text-align: center;">hundred<strong>th</strong>s</td></tr><tr class="odd"><td style="text-align: center;">千分位</td><td style="text-align: center;">thousand<strong>th</strong>s</td></tr></tbody></table><ul><li>有限小数terminating decimal 循环小数repeating decimal（循环小数会在循环的位数上加一根横线）</li><li>科学计数法scientific notation</li></ul><h3 id="比率-ratio">1.5 比率 ratio</h3><h3 id="百分比-percentage">1.6 百分比 percentage</h3><h2 id="algebra">Algebra</h2><h3 id="乘方与开方-powers-roots">2.1 乘方与开方 powers &amp; roots</h3><ul><li>指数exponent 底数base</li><li>平方根square root 立方根cube root</li></ul><h3 id="实数-real-numbers">2.2 实数 real numbers</h3><ul><li>数轴 number line</li><li>间距（interval）：不等式端点之间的实数集合</li><li>绝对值absolute value</li></ul><h3 id="变量和表达式-variable-and-experssion">2.3 变量和表达式 variable and experssion</h3><h3 id="方程-equations">2.4 方程 equations</h3><ul><li>一元线性方程linear equations with one variable</li></ul><h3 id="代数不等式-algebraic-inequalities">2.5 代数不等式 algebraic inequalities</h3><ul><li><span class="math inline">\({若0&lt;a&lt;b且m&gt;0 ，则\frac{a+m}{b+m}&gt;\frac{a}{b}}\)</span></li><li>三角不等式 <span class="math inline">\(||a|-|b||&lt;=|a+b| &lt;= |a|+|b|\)</span></li><li>三角不等式 <span class="math inline">\(||a|-|b||&lt;=|a-b| &lt;= |a|+|b|\)</span></li></ul><h3 id="函数-functions">2.6 函数 functions</h3><ul><li>自变量independent variable，因变量 dependent variable</li></ul><h3 id="代数文字题">2.7 代数文字题</h3><ol type="1"><li><p>currency: cent1分，dime10分（一角），quarter25分，nickel5分</p></li><li><p>投资问题</p><ul><li><p>discount 折扣</p></li><li><p>interest 利息</p></li><li><p>simple interest 单利：不论期限长短，仅按本金principal计算利息。<strong>本利和<span class="math inline">\(A=p(1+n*r)\)</span> n时间，r利率</strong></p></li><li><p>compound interest 复利：与单利相对，利息算入本金再继续计算，“利滚利”。<strong><span class="math inline">\(A=p(1+r)^{n}\)</span></strong></p><p><em><strong>ps</strong>.</em>单利与复利计算时，注意<strong>单位换算</strong>，如半年or三个月</p></li><li><p>rate/percent of interest 利率：年、月、日率</p></li><li><p>profit 利润 gain/loss 盈亏</p></li></ul></li><li><p>牛吃草问题：两个未知数，初始草量S0，草生长速度v，方程：<span class="math inline">\(t*n=S_0+t*v\)</span>，其中n为牛的数目</p></li><li><p>集合问题最好<strong>列表格</strong>，各个类别作表名，清晰直观</p></li></ol><h2 id="sets-permutation-combination-and-probability">Sets, Permutation, Combination and Probability</h2><h3 id="统计问题">3.1 统计问题</h3><ul><li>arithmetic mean/average 算数平均数</li><li>geometric average 几何平均数：n个数的乘积开n次方</li><li>算数<sub>大于等于几何</sub>：<span class="math inline">\(\frac{a+b}{2}&gt;=\sqrt{ab}\)</span>相等时取等号</li><li>median中位数，求中位数时先从小到大排序</li><li>mode 众数</li><li>range值域，<span class="math inline">\(range=max-min\)</span></li><li>standard deviation 标准差 <strong>最后一定记得开根号！！！</strong><span class="math inline">\(\sigma=\sqrt{\frac{\sum_{i=1}^{n}(x_i-\hat{x})^2}{n}}\)</span> <strong>ps.</strong>当题目为随机选择的n个数求标准差时，上式分母为<strong>n-1</strong></li><li>frequency distribution 频率分布</li></ul><h3 id="级数与数列">3.2级数与数列</h3><ul><li>等差数列arithmetic sequence<ul><li><span class="math inline">\(a_n=a_1+(n-1)d\)</span></li><li><span class="math inline">\(S_n=\frac{n(a_1+a_n)}{2}\)</span></li></ul></li><li>等比数列geometric sequence<ul><li><span class="math inline">\(a_n=a_1*q^{n-1}\)</span></li><li><span class="math inline">\(S_n=\frac{a_1(1-q^n)}{1-q}\)</span></li></ul></li></ul><h3 id="排列组合和概率">3.3 排列组合和概率</h3><ul><li>排列<span class="math inline">\(A_n^m=\frac{n!}{(n-m)!}\)</span></li><li>组合 <span class="math inline">\(C_n^m=\frac{A_n^m}{m!}=\frac{n!}{m!(n-m)!}\)</span></li></ul><h2 id="geometry">Geometry</h2><h3 id="平面几何-plane-geometry">4.1 平面几何 plane geometry</h3><ul><li>对顶角 vertical angle</li><li>钝角obtuse angle 锐角acute angle 直角<strong>right</strong> angle</li><li>补角supplementary angle 余角complementary angle</li></ul><h3 id="三角形的角和边-angles-and-sides-of-triangles">4.2 三角形的角和边 angles and sides of triangles</h3><ul><li><span class="math inline">\(|a-b|&lt;c&lt;a+b\)</span></li><li>设c为最大的边，若<span class="math inline">\(a^2+b^2&lt;c^2\)</span>，则为钝角三角形，若<span class="math inline">\(a^2+b^2&gt;c^2\)</span>，则为锐角三角形</li><li>等腰三角形isosceles triangles</li><li>等边三角形equilateral triangles，面积<span class="math inline">\(Area=\frac{a^2\sqrt{3}}{4}\)</span></li></ul><h3 id="四边形-quadrilaterals">4.4 四边形 quadrilaterals</h3><ul><li>square, rectangle, parallelogram平行四边形, rhombus菱形, trapezoid梯形</li></ul><h3 id="圆-circle">4.5 圆 circle</h3><ul><li>半径radius，直径diameter，弦chord（连接圆上任意两点的线段），周长circumference，弧arc</li><li>圆的切线tangent，割线secant（与圆有两个交点的直线）</li><li>圆心角central angle，圆周角inscribed angle。圆心角等于同一弧所对的圆周角的<strong>二倍</strong></li><li>扇形sector</li><li>垂径定理：垂直于弦的直径平分这段弦，也平分所对应的圆周角圆心角</li></ul><h3 id="立体几何-solids-geometry">4.7 立体几何 solids geometry</h3><ul><li>圆柱体cylinders：下底面the circular base，上底面the circular top</li><li>圆锥cones，表面积<span class="math inline">\(S=\pi{r}^2+\pi{rl}\)</span>，体积<span class="math inline">\(V=\frac{1}{3}\pi{r}^2h\)</span></li><li>球balls，表面积<span class="math inline">\(S=4\pi{r}^2\)</span>，体积<span class="math inline">\(V=\frac{4}{3}\pi{r}^3\)</span></li></ul><h3 id="坐标几何-coordinate-geometry">4.8 坐标几何 coordinate geometry</h3><ul><li>四个象限the four quadrants</li><li>斜率slope 截距intercept</li></ul><h2 id="data-interpretation">Data Interpretation</h2><ul><li>图表按比例给出drawn to scale</li></ul>]]></content>
    
    
    <categories>
      
      <category>GRE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GRE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Session-based Recommendation with Graph Neural Networks | Shu Wu</title>
    <link href="/2022/04/22/SRGCN/"/>
    <url>/2022/04/22/SRGCN/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CRIPAC-DIG/SR-GNN">参考源代码</a></p><h2 id="intro">INTRO</h2><p>previous work: Markov chains, Recurrent Neural Networks (RNNs)</p><p>提出基于GNN的SBR方法，sessions被建模成图结构数据，GNN可以捕捉items间复杂的过渡，每一session利用注意网络由全局偏好和当前兴趣组成.</p><img src="/2022/04/22/SRGCN/framework.png" class title="Framework"><p>首先将所有<strong>会话序列建模</strong>为会话图。 然后，将每个会话图逐个处理，并通过<strong>门控图神经网络</strong>获得生成的节点向量。 之后，使用<strong>注意力网络</strong>将每个会话表示为该会话的全局偏好和当前兴趣的组合。 最后，<strong>预测</strong>每个项目是每个会话的下一次点击项目的概率。</p><h2 id="the-proposed-method">The Proposed Method</h2><h3 id="constructing-session-graphs">Constructing Session Graphs</h3><h3 id="learning-item-embeddings-on-session-graphs">Learning Item Embeddings on Session Graphs</h3><h3 id="generating-session-embeddings">Generating Session Embeddings</h3><h3 id="making-recommendation-and-model-training">Making Recommendation and Model Training</h3>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Recommender Systems</tag>
      
      <tag>SR-GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Multi-behavior Recommendation with Graph Convolutional Networks | Bowen Jin</title>
    <link href="/2022/04/16/MBGCN/"/>
    <url>/2022/04/16/MBGCN/</url>
    
    <content type="html"><![CDATA[<h2 id="intro">INTRO</h2><p>传统推荐模型（协同过滤CF）只采用一种 user-item模型，面临严重的数据稀疏或冷启动问题</p><p>多行为推荐：通过辅助行为，来帮助预测用户未来对目标行为的交互</p><p>现有的研究采用：</p><ol type="1"><li>在采样过程中利用多行为数据，并建立多采样对来加强模型学习过程</li><li>尝试设计模型以捕获多行为信息</li></ol><p>现有研究的局限：</p><ol type="1"><li><p><strong>多种行为的强度</strong>没有得到充分利用。多反馈推荐模型需要从数据中揭示和进一步利用不同行为类型的各种强度。</p></li><li><p>没有考虑多种行为的<strong>语义关系</strong>。每种行为下的交互项之间应该有一些共同的特征或特殊关系，可替换或互补</p></li></ol><p>如何解决：构建一个基于多种行为数据的统一异构图</p><ol type="1"><li>将用户/项目表示为节点</li><li>特定类型的user-item项目反馈表示为图的多种类型的边</li><li>...强度和...语义建模问题转向对异构边和项目用户建模 -项目元路径</li></ol><h2 id="problem-formulation">PROBLEM FORMULATION</h2><p>交互矩阵元素级别定义： <span class="math display">\[y_{ui}^t =\begin{cases}1 &amp;\text{if u has interacted with i under behavior t}\\0 &amp;\text{otherwise}\end{cases}\]</span> <em><strong>Note</strong>:对行为的时间顺序或强度顺序没有限制</em></p><p>Input：T类行为的用户-项目交互数据，{<span class="math inline">\({Y^1, Y^2,..., Y^T}\)</span>}.</p><p>Output：一个推荐模型，用于估计用户 u 在第 T 次行为（即目标行为）下与项目 i 交互的概率</p><h2 id="methodology">METHODOLOGY</h2><img src="/2022/04/16/MBGCN/model.png" class title="MBGCN model"><p>四个组件：</p><ol type="1"><li>为用户和项目嵌入提供初始化的共享层</li><li>user-item传播层，用于学习每个行为的<strong>强度</strong>，并同时基于多行为user-item交互提取协同过滤信号</li><li>一个item-item传播层来细化item的特殊关系，或者换句话说，基于行为类型的<strong>行为语义</strong></li><li>联合预测模块</li></ol><h3 id="统一异构图">统一异构图</h3><p>无向图<span class="math inline">\({G=(V,E)}\)</span></p><p>节点集<span class="math inline">\({V}\)</span>包含用户节点和项目节点，边集<span class="math inline">\({E}\)</span>包含不同行为的不同user-item交互边.当 <span class="math inline">\({y^t_{ui}=1}\)</span> 时，将建立一条边 <span class="math inline">\({(u,i)_t}\)</span> 基于用户的共同行为在项目之间建立了一些<a href="https://blog.csdn.net/weixin_40945354/article/details/104345399">元路径</a></p><h3 id="共享嵌入层">共享嵌入层</h3><p><a href="https://www.sohu.com/a/258700791_465959">嵌入向量</a>来描述用户和项目，<strong>热向量</strong>作为输入来描述用户或项目的 ID</p><h3 id="behavior-aware-user-item-propagation">Behavior-aware User-Item Propagation</h3>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>Recommender Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Graph Neural Networks for Recommender Systems | Chen Gao</title>
    <link href="/2022/04/10/gnn-RS/"/>
    <url>/2022/04/10/gnn-RS/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/tsinghua-fib-lab/GNN-Recommender-Systems">代表性论文及其代码库</a></p><p>从四个角度对推荐系统的研究进行了分类：阶段、场景、目标和应用</p><img src="/2022/04/10/gnn-RS/fourperspectives.png" class title="fourperspectives"><h2 id="bg">BG</h2><h3 id="推荐系统">1. 推荐系统</h3><p>现代推荐系统三个阶段<em>stage</em>：</p><ul><li>匹配：核心任务是高效检索潜在相关项目，并实现用户兴趣的粗粒度建模</li><li>排序：在匹配阶段之后，来自不同渠道的多个候选项目来源被合并到一个列表中，然后通过单个排名模型进行评分。</li><li>再排序：去除某些项目或更改列表的顺序，以满足其他标准并满足业务需求</li></ul><p>不同场景<em>scenario</em>：社交推荐、顺序推荐、会话推荐、捆绑推荐、跨域推荐和多行为推荐</p><ul><li><p>社交推荐：用户交互由自己的偏好和社会因素（社会影响力和社会同质性）共同决定。</p></li><li><p>序列推荐：从这些行为序列中提取信息并预测用户的下一个交互项，</p></li><li><p>基于会话的推荐SBR：用户档案和长期历史交互是不可用的，只提供来自匿名用户的短会话数据。SBR旨在使用给定的匿名行为会话数据预测下一个项目</p></li><li><p>捆绑推荐：推荐项目组合供用户消费</p></li><li><p>跨域推荐CDR：缓解冷启动和数据稀疏问题的一种很有前途的方法，分为两类，单目标（STCDR）和双目标（DTCDR）</p></li><li><p>多行为推荐：用户在多种行为而不是仅一种行为下与推荐系统交互。对于每个用户𝑢和项目𝑣，假设有𝐾不同类型的行为{𝑦1，𝑦2，...，𝑦𝐾}。 对于第 𝑖 行为，如果用户有观察到的行为，则 𝑦𝑖 = 1，否则 𝑦𝑖 = 0。目标是提高对某类目标行为的预测准确率 𝑦𝑡。</p></li></ul><p>目标<em>objective</em>：准确性</p><ul><li>多样性 individual-level diversity &amp; system-level diversity.</li><li>解释能力 generate per-suasive explanations for how and why the item is recommended to a specific user</li><li>公平性 user fairness &amp; item fairness</li></ul><p>应用<em>application</em></p><h3 id="图神经网络">2. 图神经网络</h3><p>The rise of GNN mainly originates from the advancement of convolutional neural network (<strong>CNN</strong>) and graph representation learning (<strong>GRL</strong>)</p><ul><li><p>图构建：预先存在的图数据或从非结构化数据中抽象出图节点和边的概念</p></li><li><p>网络设计: GNN 模型可以分为光谱模型和空间模型. <em>(how?图傅里叶变换)</em> 通过迭代收集邻域信息来捕获图节点和边之间的高阶相关性.这里“信息”表示为嵌入，即低维向量。</p><ul><li><p>GCN <span class="math display">\[H^{l+1}=\delta(\hat{D}^{-\frac{1}{2}}\hat{A}\hat{D}^{-\frac{1}{2}}H^lW^l)\]</span></p></li><li><p>GraphSAGE</p></li><li><p>GAT</p><p>自动学习节点互相的影响度</p><p>通过注意力机制，对给定信息进行权重分配，权重高意味着要进行重点加工。为不同的节点指定不同的权重来聚合邻域特征（嵌入）</p><img src="/2022/04/10/gnn-RS/gat.png" class title="GAT"></li><li><p>HetGNN</p></li><li><p>HGNN</p></li></ul><img src="/2022/04/10/gnn-RS/modelscompare.png" class title="compare models"></li><li><p>模型优化：基于 GNN 的模型中的优化将 GNN 泛化的表示视为输入，将图结构（例如边、节点类）视为标签，并为训练定义<strong>损失函数</strong></p></li></ul><h3 id="why-are-gnns-required-for-recommender-systems">3. Why are GNNs required for recommender systems</h3><ul><li><p>结构数据： 将所有数据表示为图上的节点和边；可以获得用户、项目和其他特征的高质量嵌入</p></li><li><p>高阶连通性：<strong>协同过滤</strong>效果可以自然地表示为图上的多跳邻居，并通过嵌入传播和聚合将其合并到学习的表示中。</p></li><li><p>监督信号：监督信号在收集的数据中通常是稀疏的，而基于 GNN 的模型可以在表示学习过程中利用<strong>半监督信号</strong>来缓解这个问题。</p></li></ul><h2 id="challenges">CHALLENGES</h2><h3 id="图构建">1. 图构建</h3><p>两个任务：将数据输入构建为图形结构数据； 将推荐目标重新组织为图上的任务。</p><p><em>//TODO 表示学习，节点嵌入</em></p><ul><li>节点</li><li>边</li></ul><h3 id="网络设计">2. 网络设计</h3><p>传播层，如何选择路径，聚合函数也有多种选择</p><h3 id="模型优化">3. 模型优化</h3><p>BPR loss, 即让正样本和负样本的得分之差尽可能达到最大</p><img src="/2022/04/10/gnn-RS/bprloss.png" class title="BPR loss"><p>数据采样。 在基于 GNN 的推荐中，要对正项或负项进行采样，采样方式高度依赖于图结构</p><h3 id="计算效率">4. 计算效率</h3><h2 id="existing-methods">EXISTING METHODS</h2><h3 id="gnn-in-session-based-recommendation">GNN in Session-based Recommendation</h3><ol type="1"><li><p>two challenges:</p><ul><li><p>how to model the item transition pattern in session data --&gt;item transitions</p></li><li><p>how to activate user’s core interests from noisy data --&gt;the information propagation on the graph</p></li></ul></li></ol><h3 id="gnn-in-multi-behavior-recommendation">GNN in Multi-behavior Recommendation</h3><ul><li>如何对多个行为与目标行为之间的关系进行建模，</li><li>如何通过行为对项目的语义进行建模，</li></ul>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GNN</tag>
      
      <tag>Recommender Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐系统中的图神经网路</title>
    <link href="/2022/03/14/gcn/"/>
    <url>/2022/03/14/gcn/</url>
    
    <content type="html"><![CDATA[<p>gnn图神经网络</p><p>gat图注意力网络</p><p>gcn 图卷积网络</p><h2 id="什么是gnn">什么是GNN</h2><ol type="1"><li>CNN: 通过卷积得到下一层的feature map</li><li>在图结构中，通过对邻居节点的表示进行计算得到下一层feature map，再利用传播过程所得到的各层表示来进一步完成后续任务（例如节点分类/边预测/节点内积预测匹配度等等）</li><li>根据结构设计不同，GNN模型可以划分为以下几种，RecGNN、ConvGNN、STGNN和GAE</li></ol><h2 id="为什么使用gnn">为什么使用GNN</h2><ol type="1"><li>一般推荐：将用户偏好视为静态的，学习用户和物品的静态表示</li><li>序列化推荐：认为用户偏好随时间动态变化，根据交互序列来预测用户下一个可能喜欢的物品</li></ol><p>除了数据方面，对于具体的学习过程而言，GNN具有以下优点 ：</p><ul><li>对于 general recommendation：GNN可以通过节点聚合显式地编码协同信号来增强用户和物品的表示学习能力，相比与其他模型，GNN对多跳信息的建模更加灵活方便。</li><li>对于 sequential recommendation：将序列数据转换为序列图可以更灵活地进行项目选择的原始转换，并且，GNN可以通过环的结构捕获隐含在顺序行为中的复杂用户偏好。</li></ul><h2 id="图信号处理">图信号处理</h2><p>图信号处理基本理论延伸到GCN中</p><ol type="1"><li>拉普拉斯矩阵： <span class="math display">\[L = D - A\]</span></li></ol><p><span class="math display">\[D_{ii}=\sum_j{A{ij}} \text{    表示节点}vi\text{的度}\]</span></p><p>​ 元素级别定义： <span class="math display">\[L_{ij}=\begin{cases}deg(v_i) &amp;\text{if }i=j\\-1 &amp;\text{if }e_{ij} \in E\\0 &amp;\text{otherwise}\end{cases}\]</span></p><p>​ 正则化形式: <span class="math display">\[L_{sym}=D^{-1/2}LD^{1/2}\]</span> ​ 元素级别定义： <span class="math display">\[L_{sym}[i,j]=\begin{cases}1 &amp;\text{if }i=j\\\frac{-1}{\sqrt{deg(v_i)deg(v_j)}} &amp;\text{if }e_{ij} \in E\\0 &amp;\text{otherwise}\end{cases}\]</span></p><ol start="2" type="1"><li><p>图傅里叶变换</p><p>将拉普拉斯矩阵正交对角化 <span class="math display">\[L = D - A = V \Lambda V^T\]</span> 图傅里叶变换： <span class="math display">\[\hat{x}=V^Tx\]</span></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android（一）应用基础知识</title>
    <link href="/2022/01/09/android/"/>
    <url>/2022/01/09/android/</url>
    
    <content type="html"><![CDATA[<h2 id="应用组件">应用组件</h2><h3 id="activity">activity</h3><ul><li><p>活动（activity）是用户操作的可视化界面；它为用户提供了一个完成操作指令的窗口。当我们创建完毕Activity之后，需要调用<code>setContentView()</code>方法来完成界面的显示；以此来为用户提供交互的入口。</p></li><li><p>一个activity就是一个单独的窗口</p></li><li><p>activity之间通过intent进行通信</p></li><li><p>需要在AndroidManifest.xml配置相关信息</p></li><li><p>存在自己的生命周期</p></li></ul><h3 id="service">service</h3><ul><li><p>通常用作在<strong>后台</strong>处理耗时的逻辑，与Activity一样，它存在自己的生命周期，也需要在AndroidManifest.xml配置相关信息。</p></li><li><p>是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求<strong>长期运行</strong>的任务。服务的运行<strong>不依赖于任何用户界面</strong>，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。</p></li><li><p>并不运行在一个独立的进程当中，<strong>依赖</strong>于创建服务时所在的应用程序进程。某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行</p></li><li><p>两种启动方式<code>startService()</code>和<code>bindService()</code></p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr class="header"><th style="text-align: center;">种类</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>startService()</code></td><td style="text-align: center;">由其他组件调用<code>startService()</code>方法启动的，这导致服务的<code>onStartCommand()</code>方法被调用。当服务是started状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用<code>stopSelf()</code>方法停止，或者由其他组件调用<code>stopService()</code>方法停止。</td></tr><tr class="even"><td style="text-align: center;"><code>bindService()</code></td><td style="text-align: center;">调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</td></tr></tbody></table></li><li><p>Service组件：没有GUI；需要继承Service基类；通常用于为其他组件提供<strong>后台服务</strong>或<strong>监控</strong>其他组件的运行状态。</p></li></ul><h3 id="广播接收者broadcast-receiver">广播接收者（Broadcast receiver）</h3><p>在Android中，<strong>广播</strong>是一种广泛运用的在应用程序之间传输信息的机制。而<strong>广播接收器</strong>是对发送出来的广播进行<strong>过滤接受</strong>并<strong>响应</strong>的一类组件。</p><ul><li>可以使用广播接收器对外部事件进行过滤，只对感兴趣的外部事件进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或service来响应它们收到的信息，或者用NotificationManager来通知用户</li><li>两种注册方法：<ul><li>程序<strong>动态注册</strong>（在运行时的代码中使用<code>Context.registerReceive（）</code>进行注册）:当用来注册的Activity关掉后，广播随即失效</li><li>AndroidManifest.xml文件中进行<strong>静态注册</strong>：只要设备是开启状态，广播接收器也是打开着的。即如果app本身未启动，该app订阅的广播在触发时也会对它起作用</li></ul></li></ul><h3 id="内容提供者content-provider">内容提供者（Content provider）</h3><ul><li><p>android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据</p></li><li><p>只有需要在多个应用程序间共享数据是才需要内容提供者</p></li><li><p>ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见</p></li><li><p>开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作</p></li><li><p>ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理</p></li></ul><h3 id="启动方法">启动方法</h3><p>每种组件都有不同的启动方法：</p><ul><li>如要启动 Activity，您可以向 <code>startActivity()</code> 或 <code>startActivityForResult()</code> 传递 <code>Intent</code>（当您想让 Activity 返回结果时），或者为其安排新任务。</li><li>在 Android 5.0（API 级别 21）及更高版本中，您可以使用 <code>JobScheduler</code> 类来调度操作。对于早期 Android 版本，您可以通过向 <code>startService()</code> 传递 <code>Intent</code> 来启动服务（或对执行中的服务下达新指令）。您也可通过向将 <code>bindService()</code> 传递 <code>Intent</code> 来绑定到该服务。</li><li>您可以通过向 <code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code> 或 <code>sendStickyBroadcast()</code> 等方法传递 <code>Intent</code> 来发起广播。</li><li>您可以通过在 <code>ContentResolver</code> 上调用 <code>query()</code>，对内容提供程序执行查询。</li></ul><h2 id="intent和intent过滤器">Intent和Intent过滤器</h2>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c#</title>
    <link href="/2021/11/11/c-sharp/"/>
    <url>/2021/11/11/c-sharp/</url>
    
    <content type="html"><![CDATA[<h2 id="net框架及开发环境">.NET框架及开发环境</h2><h3 id="应用程序体系结构的类型">应用程序体系结构的类型</h3><ul><li>单层体系结构</li><li>双层：客户端、服务器端</li><li>三层：三个相互独立的服务层</li><li>N层</li></ul><h3 id="net框架的组成">.NET框架的组成</h3><ol type="1"><li>.NET Framework<ul><li>服务和类的集合</li><li>在.NET应用程序和操作系统之间以<strong>层</strong>的方式存在</li><li>封装了调试和安全服务等早期各种程序设计语言所具备的许多基本功能。</li></ul></li><li>.NET Framework基础类或.NET类构架</li><li>公共语言执行环境</li></ol><h3 id="net框架的优点">.NET框架的优点</h3><h3 id="net两种交互模式">.NET两种交互模式</h3><ul><li>C/S</li><li>B/S</li></ul>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web技术之CSS</title>
    <link href="/2021/10/06/Web%E6%8A%80%E6%9C%AF%E4%B9%8BCSS/"/>
    <url>/2021/10/06/Web%E6%8A%80%E6%9C%AF%E4%B9%8BCSS/</url>
    
    <content type="html"><![CDATA[<h2 id="css简介">CSS简介</h2><ul><li><p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</p></li><li><p>样式定义<strong>如何显示</strong> HTML 元素</p></li><li><p>样式通常存储在<strong>样式表</strong>中</p></li><li><p>把样式添加到 HTML 4.0 中，是为了<strong>解决内容与表现分离的问题</strong></p></li><li><p><strong>外部样式表</strong>可以极大提高工作效率</p></li><li><p>外部样式表通常存储在 <strong>CSS 文件</strong>中</p></li><li><p>多个样式定义可<strong>层叠</strong>为一个</p></li></ul><h2 id="css语法">CSS语法</h2><h3 id="css-实例">CSS 实例</h3><p>CSS声明总是以分号(;)结束，声明总以大括号({})括起来:</p><figure><img src="https://www.runoob.com/wp-content/uploads/2013/07/632877C9-2462-41D6-BD0E-F7317E4C42AC.jpg" alt="rules"><figcaption aria-hidden="true">rules</figcaption></figure><p><strong>选择器</strong>通常是您需要改变样式的 HTML 元素。</p><p>每条声明由一个属性和一个值组成。</p><p><strong>属性</strong>（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。</p><h3 id="css-注释">CSS 注释</h3><p>CSS注释以 <code>/*</code> 开始, 以 <code>*/</code> 结束</p><h2 id="css-id和class">CSS id和class</h2><h3 id="id-选择器">id 选择器</h3><p>可以为标有特定 id 的 HTML 元素指定特定的样式。（一个元素）</p><p>HTML元素以id属性来<strong>设置</strong>id选择器,CSS 中 id 选择器以 "<strong>#</strong>" 来<strong>定义</strong></p><p><strong>注意</strong>：<em>ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*在CSS中定义id选择器*/</span><br><span class="hljs-selector-id">#para1</span> <br>&#123;    <br>    <span class="hljs-attribute">text-align</span>:center;    <br>    <span class="hljs-attribute">color</span>:red; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="class-选择器">class 选择器</h3><p>class 选择器用于描述一组元素的样式，class可以在<strong>多个元素</strong>中使用。</p><p>class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点"."号显示：</p><p><strong>注意</strong>：<em>类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。</em></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*所有拥有 center 类的 HTML 元素均为居中*/</span><br><span class="hljs-selector-class">.center</span> &#123;<span class="hljs-attribute">text-align</span>:center;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*指定特定的HTML元素使用class/*</span><br><span class="hljs-comment">/*所有的 p 元素使用 class=&quot;center&quot; 让该元素的文本居中*/</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.center</span> &#123;<span class="hljs-attribute">text-align</span>:center;&#125;<br></code></pre></td></tr></table></figure><h2 id="css创建">CSS创建</h2><h3 id="外部样式表">外部样式表</h3><p>每个页面使用 <code>&lt;link&gt;</code>标签链接到样式表。 <code>&lt;link&gt;</code>标签在（文档的）头部</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。</p><p>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存</p><h3 id="内部样式表">内部样式表</h3><p>使用 <code>&lt;style&gt;</code> 标签在文档头部定义内部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        hr &#123;<span class="hljs-attribute">color</span>:sienna;&#125; </span><br><span class="css">        <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;&#125; </span><br><span class="css">        <span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;images/back40.gif&quot;</span>);&#125; </span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="内联样式">内联样式</h3><p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:sienna;margin-left:20px&quot;</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<em>不要在属性值与单位之间留有空格（如："margin-left: 20 px" ），正确的写法是 "margin-left: 20px" 。</em></p><h3 id="多重样式优先级">多重样式优先级</h3><p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><h2 id="css背景">CSS背景</h2><table><thead><tr class="header"><th style="text-align: center;">Property</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><a href="https://www.runoob.com/cssref/css3-pr-background.html">background</a></td><td style="text-align: center;">简写属性，作用是将背景属性设置在一个声明中。</td></tr><tr class="even"><td style="text-align: center;"><a href="https://www.runoob.com/cssref/pr-background-attachment.html">background-attachment</a></td><td style="text-align: center;">背景图像是否固定或者随着页面的其余部分滚动。</td></tr><tr class="odd"><td style="text-align: center;"><a href="https://www.runoob.com/cssref/pr-background-color.html">background-color</a></td><td style="text-align: center;">设置元素的背景颜色。</td></tr><tr class="even"><td style="text-align: center;"><a href="https://www.runoob.com/cssref/pr-background-image.html">background-image</a></td><td style="text-align: center;">把图像设置为背景。</td></tr><tr class="odd"><td style="text-align: center;"><a href="https://www.runoob.com/cssref/pr-background-position.html">background-position</a></td><td style="text-align: center;">设置背景图像的起始位置。</td></tr><tr class="even"><td style="text-align: center;"><a href="https://www.runoob.com/cssref/pr-background-repeat.html">background-repeat</a></td><td style="text-align: center;">设置背景图像是否及如何重复。</td></tr></tbody></table><h2 id="css文本属性">CSS文本属性</h2><table><thead><tr class="header"><th style="text-align: left;">属性</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-color.html">color</a></td><td style="text-align: center;">设置文本颜色</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-direction.html">direction</a></td><td style="text-align: center;">设置文本方向。</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-letter-spacing.html">letter-spacing</a></td><td style="text-align: center;">设置字符间距（单词间距word-spacing）</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-dim-line-height.html">line-height</a></td><td style="text-align: center;">设置行高</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-text-align.html">text-align</a></td><td style="text-align: center;">对齐元素中的文本</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-text-decoration.html">text-decoration</a></td><td style="text-align: center;">向文本添加修饰</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-text-indent.html">text-indent</a></td><td style="text-align: center;">缩进元素中文本的首行</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/css3-pr-text-shadow.html">text-shadow</a></td><td style="text-align: center;">设置文本阴影</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-text-transform.html">text-transform</a></td><td style="text-align: center;">控制元素中的字母</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-unicode-bidi.html">unicode-bidi</a></td><td style="text-align: center;">设置或返回文本是否被重写</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-pos-vertical-align.html">vertical-align</a></td><td style="text-align: center;">设置元素的垂直对齐</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-white-space.html">white-space</a></td><td style="text-align: center;">设置元素中空白的处理方式</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-text-word-spacing.html">word-spacing</a></td><td style="text-align: center;">设置字间距</td></tr></tbody></table><h2 id="css字体">CSS字体</h2><h3 id="用em来设置字体大小">用em来设置字体大小</h3><p>1em和当前字体大小相等。在浏览器中默认的文字大小是16px。</p><p>因此，1em的默认大小是16px。可以通过下面这个公式将像素转换为em：<strong>px/16=em</strong></p><p>通过百分比和EM组合，设置 <code>&lt;body&gt;</code>元素的默认字体大小的是百分比</p><table><thead><tr class="header"><th style="text-align: left;">Property</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-font-font.html">font</a></td><td style="text-align: left;">在一个声明中设置所有的字体属性</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-font-font-family.html">font-family</a></td><td style="text-align: left;">指定文本的字体系列</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-font-font-size.html">font-size</a></td><td style="text-align: left;">指定文本的字体大小</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-font-font-style.html">font-style</a></td><td style="text-align: left;">指定文本的字体样式</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-font-font-variant.html">font-variant</a></td><td style="text-align: left;">以小型大写字体或者正常字体显示文本。</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/cssref/pr-font-weight.html">font-weight</a></td><td style="text-align: left;">指定字体的粗细。</td></tr></tbody></table><p><em>注意</em>：将italic理解成 是使用文字的斜体，oblique 是让没有斜体属性的文字倾斜！对于没有斜体的字体应该使用 oblique 属性值来实现倾斜的文字效果。</p><h2 id="css链接">CSS链接</h2><ul><li>a:link - 正常，未访问过的链接</li><li>a:visited - 用户已访问过的链接</li><li>a:hover - 当用户鼠标放在链接上时</li><li>a:active - 链接被点击的那一刻</li></ul><p>改变属性color、text-decoration、background-color</p><p><strong>注意</strong>：a:hover 必须跟在 a:link 和 a:visited后面；a:active 必须跟在 a:hover后面</p><h2 id="css列表">CSS列表</h2><p>list-style-type，list-style-image</p><h3 id="浏览器兼容性解决方案">浏览器兼容性解决方案</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span><br>&#123;<br>    <span class="hljs-attribute">list-style-type</span>: none;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><br>&#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">sqpurple.gif</span>);<br>    <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>    <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0px</span> <span class="hljs-number">5px</span>; <br>    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">14px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>例子解释：</p><ul><li>ul:<ul><li>设置列表类型为没有列表项标记</li><li>设置填充和边距 0px（浏览器兼容性）</li><li>使用 <code>margin:0</code> 和 <code>padding:0</code> 来移除小标记（如内边距和外边距）</li></ul></li><li>ul 中所有 li:<ul><li>设置图像的 URL，并设置它只显示一次（无重复）</li><li>您需要的定位图像位置（左 0px 和上下 5px）</li><li>用 padding-left 属性把文本置于列表中</li></ul></li></ul><h3 id="简写属性list-style">简写属性<code>list-style</code></h3><p>按顺序设置如下属性：</p><ul><li>list-style-type</li><li>list-style-position</li><li>list-style-image</li></ul><p>如果上述值丢失一个，其余仍在指定的顺序，就没关系。</p><h2 id="盒子模型">盒子模型</h2><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p><img src="https://www.runoob.com/images/box-model.gif" alt="box_model" style="zoom:80%;"></p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><p>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</p><p>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</p><h3 id="边框border">边框border</h3><ul><li><p>上右下左</p></li><li><p><code>width</code>, <code>style</code>, <code>colour</code> / 四个方向的边框 -&gt; 可分开也可简写</p></li></ul><h3 id="轮廓outline">轮廓<code>outline</code></h3><ul><li><p>位于边框<code>border</code>边缘的外围，不会增加额外的width或者height，可起到突出元素的作用。</p></li><li><p>轮廓属性指定元素轮廓的样式<code>style</code>、颜色<code>color</code>和宽度<code>width</code>。</p></li></ul><h3 id="外边距margin">外边距margin</h3><ul><li>清除周围的（外边框）元素区域</li><li>没有背景颜色，是完全透明的，即<strong>只能改变width</strong>（不用指定）</li><li>margin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性</li><li>可简写</li></ul><p>### 填充 / 内边距padding</p><ul><li><p>定义元素边框border与元素内容content之间的空间</p></li><li><p>同margin，无颜色，只能改变距离</p></li></ul><h2 id="分组与嵌套">分组与嵌套</h2><h3 id="分组选择器">分组选择器</h3><p>每个选择器用逗号分隔</p><h3 id="嵌套选择器">嵌套选择器</h3><ul><li><strong>p{ }</strong>: 为所有 <strong>p</strong> 元素指定一个样式。</li><li><strong>.marked{ }</strong>: 为所有 <strong>class="marked"</strong> 的元素指定一个样式。</li><li><strong>.marked p{ }</strong>: 为所有 <strong>class="marked"</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</li><li><strong>p.marked{ }</strong>: 为所有 <strong>class="marked"</strong> 的 <strong>p</strong> 元素指定一个样式。</li></ul><h2 id="display显示-与-visibility可见性">Display(显示) 与 Visibility（可见性）</h2><p>隐藏一个元素可以通过把display属性设置为"none"，或把visibility属性设置为"hidden"。但是这两种方法会产生不同的结果：</p><ul><li><p><code>visibility:hidden</code>可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然<strong>会影响布局</strong>。(visiable collapse-&gt;是与 table 相关的元素, 占用的空间会释放)</p></li><li><p><code>display:none</code>可以隐藏某个元素，且隐藏的元素<strong>不会占用任何空间</strong>。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。</p></li></ul><p>display——块和内联元素</p><p>修改display的属性值为inline/block</p><p><strong>PS</strong>：</p><p><strong>块级元素(block)特性：</strong></p><ul><li>总是<strong>独占一行</strong>，表现为另起一行开始，而且其后的元素也必须另起一行显示;</li><li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</li></ul><p><strong>内联元素(inline)特性：</strong></p><ul><li>和相邻的内联元素在同一行;</li><li>宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变，就是里面文字或图片的大小;</li></ul><h2 id="position定位">Position(定位)</h2><h3 id="static">static</h3><p>默认值，即没有定位，遵循正常的文档流对象</p><p>静态定位的元素不会受到 top, bottom, left, right影响。</p><h3 id="relative">relative</h3><p>定位相对其正常位置（可为负，如left:-20px表示向左侧位置左移20像素）</p><h3 id="fixed">fixed</h3><p>元素的位置相对于浏览器窗口是固定位置。</p><h3 id="absolute">absolute</h3><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>&lt;html&gt;</code></p><p>不占空间，会与其他重叠</p><h3 id="sticky">sticky</h3><p>基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换</p><p>元素定位表现为在跨越<strong>特定阈值</strong>前为相对定位，之后为固定定位。指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h2 id="float浮动">Float(浮动)</h2><h3 id="浮动元素">浮动元素</h3><p>元素的水平方向浮动，意味着元素<strong>只能左右移动</strong>而不能上下移动。</p><p>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</p><h3 id="清除浮动">清除浮动</h3><p>clear 属性指定元素两侧不能出现浮动元素</p><h2 id="水平-垂直对齐">水平 &amp; 垂直对齐</h2><h3 id="元素居中对齐">元素居中对齐</h3><p>可以使用 <strong>margin: auto;</strong>设置到元素的宽度将防止它溢出到容器的边缘</p><p><strong>注意:</strong> 如果没有设置 <strong>width</strong> 属性(或者设置 100%)，居中对齐将不起作用。</p><h3 id="文本居中对齐">文本居中对齐</h3><p>为了文本在元素内居中对齐，可以使用 <strong>text-align: center;</strong></p><h3 id="图片居中对齐">图片居中对齐</h3><p>使用 <strong>margin: auto;</strong> 并将它放到 <strong>块</strong> 元素中，即<strong>display: block;</strong></p><h3 id="左右对齐---使用定位方式">左右对齐 - 使用定位方式</h3><p>使用 <strong>position: absolute;</strong></p><strong>提示:</strong> 当使用 <strong>position</strong> 来对齐元素时, 通常 **<body><p>** 元素会设置 <strong>margin</strong> 和 <strong>padding</strong> 。 这样可以避免在不同的浏览器中出现可见的差异</p><h3 id="左右对齐---使用float方式">左右对齐 - 使用float方式</h3><h3 id="垂直对齐">垂直对齐</h3><p>设置容器上下 padding 相同实现垂直居中和使用 line-height=height 实现垂直居中仅对单行文本有效，当文本行数超过单行时：</p><ul><li>1）<strong>padding</strong>：文本仍然处于容器垂直居中的位置，但是容器的 height 会随着文本行数的增加而增大；</li><li>2）<strong>line-height=height</strong>：容器的 height 不变，line-height 是文本的行间距，文本会溢出容器显示；</li></ul><p>多行文本可使用 <strong>vertical-align: middle;</strong> 来实现元素的垂直居中，但是如果子元素的内容体积大于父元素的内容体积时，仍然会溢出，后面需要使用文字溢出处理来解决。</p><h2 id="组合选择器">组合选择器</h2><h3 id="后代选择器">后代选择器</h3><p>以空格<code></code> 分隔</p><p>用于选取某元素的后代元素</p><h3 id="子元素选择器">子元素选择器</h3><p>以大于 <strong>&gt;</strong> 号分隔</p><p>只能选择作为某元素直接/一级子元素的元素</p><h3 id="相邻兄弟选择器">相邻兄弟选择器</h3><p>以加号 <strong>+</strong> 分隔</p><p>可选择紧接在另一元素后的元素，且二者有相同父元素</p><h3 id="后续兄弟选择器">后续兄弟选择器</h3><p>以波浪号 <strong>～</strong> 分隔</p><p>选取所有指定元素之后的相邻兄弟元素</p><h2 id="创建导航栏">创建导航栏</h2><h3 id="垂直导航栏">垂直导航栏</h3><h3 id="水平导航栏">水平导航栏</h3><p>想链接到具有相同的大小，必须使用浮动</p><h4 id="内联列表项">内联列表项</h4><p><code>display:inline;</code> -默认情况下，<code>&lt;li&gt;</code>元素是块元素。在这里，我们删除换行符之前和之后每个列表项，以显示一行。</p><h4 id="浮动列表项">浮动列表项</h4><ul><li><code>float:left</code>- 使用浮动块元素的幻灯片彼此相邻</li><li><code>display:block</code>- 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度(<strong>改变的是a元素而不是li元素</strong>)</li><li><code>width:60px</code> - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度</li></ul><iframe width="100%" height="300" src="https://c.runoob.com/iframe/3513" allowfullscreen="allowfullscreen" frameborder="0"></iframe></body>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web技术之HTML</title>
    <link href="/2021/09/28/Web%E6%8A%80%E6%9C%AF%E4%B9%8BHTML/"/>
    <url>/2021/09/28/Web%E6%8A%80%E6%9C%AF%E4%B9%8BHTML/</url>
    
    <content type="html"><![CDATA[<h2 id="html标题">HTML标题</h2><p>通过 <code>&lt;h1&gt; - &lt;h6&gt;</code> 标签进行定义的</p><ul><li>浏览器会自动地在标题的前后添加空行</li><li>请确保将 HTML 标题 标签只用于标题。不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题</li></ul><h2 id="html链接">HTML链接</h2><h2 id="html头部head">HTML头部<code>&lt;head&gt;</code></h2><p><code>&lt;head&gt;</code> 元素包含了所有的头部标签元素。在 <code>&lt;head&gt;</code>元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。</p><h3 id="title"><code>&lt;title&gt;</code></h3><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><h3 id="base"><code>&lt;base&gt;</code></h3><p>定义了页面链接标签的默认链接地址</p><h3 id="link"><code>&lt;link&gt;</code></h3><ul><li><p>定义了文档与外部资源之间的关系。</p></li><li><p>通常用于链接到样式表</p></li></ul><h3 id="style"><code>&lt;style&gt;</code></h3><p>定义了HTML文档的样式文件</p><h3 id="meta"><code>&lt;meta&gt;</code></h3><p>META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。</p><h3 id="script"><code>&lt;script&gt;</code></h3><p>用于加载脚本文件，如： JavaScript。</p><h2 id="html样式css">HTML样式CSS</h2><p>CSS 可以通过以下方式添加到HTML中:</p><ul><li>内联样式- 在HTML元素中使用"style" <strong>属性</strong></li><li>内部样式表 -在HTML文档头部<code>&lt;head&gt;</code> 区域使用<code>&lt;style&gt;</code><strong>元素</strong> 来包含CSS</li><li>外部引用 - 使用外部 CSS <strong>文件</strong></li></ul><h3 id="内联样式">内联样式</h3><p>在相关的标签中使用<code>style</code>，多个属性之间用；间隔</p><ul><li><p><code>background-color</code>（背景色）定义一个元素的背景颜色</p></li><li><p><code>font-family</code>（字体），<code>color</code>（颜色），和<code>font-size</code>（字体大小）属性来定义字体的样式</p></li><li><p><code>text-align</code>（文字对齐）属性指定文本的水平与垂直对齐方式</p></li></ul><h3 id="内部样式表">内部样式表</h3><p>在<code>&lt;head&gt;</code> 部分通过 <code>&lt;style&gt;</code>标签定义内部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>:yellow;&#125;</span><br><span class="css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>:blue;&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="外部样式表">外部样式表</h3><p>使用外部样式表，可以通过更改一个文件来改变整个站点的外观。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="html图像">HTML图像</h2><h3 id="图像标签-img和源属性src">图像标签（ <code>&lt;img&gt;</code>）和源属性（Src）</h3><p>在 HTML 中，图像由<code>&lt;img&gt;</code> 标签定义。</p><p><code>&lt;img&gt;</code> 是空标签，意思是说，它只包含属性，并且没有闭合标签。</p><p>要在页面上显示图像，你需要使用源属性（src）。src 指 "source"。源属性的值是图像的 URL 地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;some_text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="alt属性">Alt属性</h3><p>alt 属性用来为图像定义一串预备的可替换的文本。</p><p>在浏览器无法载入图像时，替换文本属性告诉读者失去的信息。此时，浏览器将<strong>显示这个替代性的文本</strong>而不是图像</p><h3 id="height高度-与-width宽度">height（高度） 与 width（宽度）</h3><h2 id="html表格">HTML表格</h2><p>表格由 <code>&lt;table&gt;</code> 标签来定义。每个表格均有若干行（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干单元格（由 <code>&lt;td&gt;</code> 标签定义，即指表格数据table data）。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p><ul><li><p>边框，设置<code>&lt;table&gt;</code>属性border</p></li><li><p>单元格跨行/跨列，设置<code>&lt;th&gt;</code>属性<code>rowspan</code>/<code>colspan</code></p></li><li><p>格边距，设置<code>&lt;table&gt;</code>属性<code>cellpadding</code></p></li><li><p>格间距，设置<code>&lt;table&gt;</code>属性<code>cellspacing</code></p></li></ul><table><thead><tr class="header"><th style="text-align: left;">标签</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>&lt;table&gt;</code></td><td style="text-align: left;">定义表格</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;th&gt;</code></td><td style="text-align: left;">定义表格的表头，显示为<strong>粗体居中</strong>的文本</td></tr><tr class="odd"><td style="text-align: left;"><code>&lt;tr&gt;</code></td><td style="text-align: left;">定义表格的行</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;td&gt;</code></td><td style="text-align: left;">定义表格单元</td></tr><tr class="odd"><td style="text-align: left;"><code>&lt;caption&gt;</code></td><td style="text-align: left;">定义表格标题</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;colgroup&gt;</code></td><td style="text-align: left;">定义表格列的组</td></tr><tr class="odd"><td style="text-align: left;"><code>&lt;col&gt;</code></td><td style="text-align: left;">定义用于表格列的属性</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;thead&gt;</code></td><td style="text-align: left;">定义表格的页眉</td></tr><tr class="odd"><td style="text-align: left;"><code>&lt;tbody&gt;</code></td><td style="text-align: left;">定义表格的主体</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;tfoot&gt;</code></td><td style="text-align: left;">定义表格的页脚</td></tr></tbody></table><h2 id="html列表">HTML列表</h2><ul><li>无序列表<code>&lt;ul&gt;</code></li><li>有序列表始于 <code>&lt;ol&gt;</code>标签</li><li>有序和无序列表的每个列表项始于 <code>&lt;li&gt;</code>标签</li></ul><table><thead><tr class="header"><th style="text-align: left;">标签</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>&lt;ol&gt;</code></td><td style="text-align: left;">定义有序列表，里面只能包含li</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;ul&gt;</code></td><td style="text-align: left;">定义无序列表，里面只能包含li</td></tr><tr class="odd"><td style="text-align: left;"><code>&lt;li&gt;</code></td><td style="text-align: left;">定义列表项(list item)</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;dl&gt;</code></td><td style="text-align: left;">自定义列表(definition lists)，只能包含dd和dt</td></tr><tr class="odd"><td style="text-align: left;"><code>&lt;dt&gt;</code></td><td style="text-align: left;">自定义列表项目(definition term)</td></tr><tr class="even"><td style="text-align: left;"><code>&lt;dd&gt;</code></td><td style="text-align: left;">定义自定列表项的描述(definition description)</td></tr></tbody></table><h2 id="html区块">HTML区块</h2><table><thead><tr class="header"><th>区块元素</th><th>内联元素</th></tr></thead><tbody><tr class="odd"><td>在浏览器显示时，通常会以新行来开始（和结束）</td><td>显示时通常不会以新行开始</td></tr><tr class="even"><td><code>&lt;div&gt;</code></td><td><code>&lt;span&gt;</code></td></tr><tr class="odd"><td>定义了文档的区域，块级 (block-level)</td><td>用来组合文档中的行内元素， 内联元素(inline)</td></tr></tbody></table><h2 id="html-表单">HTML 表单</h2><p>表单是一个包含表单元素的区域。使用表单标签 <code>&lt;form&gt;</code> 来设置</p><p>多数情况下被用到的表单标签是输入标签（<code>&lt;input&gt;</code>）。</p><p>输入类型是由类型属性（type）定义的。大多数经常被用到的输入类型如下：</p><h3 id="文本域text-fields">文本域（Text Fields）</h3><p><code>&lt;input type="text"&gt;</code></p><form>First name: <input type="text" name="firstname"><br> Last name: <input type="text" name="lastname"></form><h3 id="密码字段">密码字段</h3><p><code>&lt;input type="password"&gt;</code></p><form>Password: <input type="password" name="pwd"></form><h3 id="单选按钮radio-buttons">单选按钮（Radio Buttons）</h3><p><code>&lt;input type="radio"&gt;</code></p><form>males: <input type="radio" name="m"><br> females: <input type="radio" name="fm"></form><h3 id="复选框checkboxes">复选框（Checkboxes）</h3><p><code>&lt;input type="checkbox"&gt;</code></p><form><input type="checkbox" name="vehicle" value="Bike">I have a bike<br> <input type="checkbox" name="vehicle" value="Car">I have a car</form><h3 id="提交按钮submit-button">提交按钮(Submit Button)</h3><p><code>&lt;input type="submit"&gt;</code></p><form name="input" action="html_form_action.php" method="get">Username: <input type="text" name="user"> <input type="submit" value="Submit"></form><h2 id="html框架">HTML框架</h2><p>通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。</p><p><code>&lt;iframe src="URL"&gt;&lt;/iframe&gt;</code></p><h3 id="使用iframe来显示目标链接页面">使用iframe来显示目标链接页面</h3><p>iframe可以显示一个目标链接的页面</p><p>目标链接的target属性必须指向iframe的name，如下实例:</p><iframe src="demo_iframe.htm" name="iframe_a"></iframe><p><a href="http://www.runoob.com" target="iframe_a" rel="noopener">RUNOOB.COM</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python数值运算（一）NumPy</title>
    <link href="/2021/08/19/numpy/"/>
    <url>/2021/08/19/numpy/</url>
    
    <content type="html"><![CDATA[<h1 id="numpy">NumPy</h1><h2 id="numpy简介">NumPy简介</h2><p>维基百科是这样说的</p><blockquote><p>NumPy是Python语言的一个扩展程序库。<strong>支持高阶大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</strong>NumPy的前身Numeric最早是由Jim Hugunin与其它协作者共同开发，2005年，Travis Oliphant在Numeric中结合了另一个同性质的程序库Numarray的特色，并加入了其它扩展而开发了NumPy。NumPy为开放源代码并且由许多协作者共同维护开发。</p><p>NumPy提供了与MATLAB相似的功能与操作方式，因为两者皆为解释型语言，并且都可以让用户在针对数组或矩阵运算时提供较标量运算更快的性能。两者相较之下，MATLAB提供了大量的扩展工具箱（例如Simulink）；而NumPy则是根基于Python这个更现代、完整并且开放源代码的编程语言之上。此外NumPy也可以结合其它的Python扩展库。例如SciPy，这个库提供了更多与MATLAB相似的功能；以及Matplotlib，这是一个与MATLAB内置绘图功能类似的库。而从本质上来说，<strong>NumPy与MATLAB同样是利用BLAS与LAPACK来提供高效率的线性代数运算。</strong></p></blockquote><p>~~<em>本菜鸡上学期摸鱼没听过python课，借着暑假学习下numpy和pandas来准备九月的数模国赛</em></p><h2 id="numpy-数组对象-ndarray">NumPy 数组对象 ndarray</h2><ol type="1"><li>属性</li></ol><table><thead><tr class="header"><th style="text-align: center;">属性</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>ndim</code></td><td style="text-align: center;">返回int，数组<strong>维数</strong></td></tr><tr class="even"><td style="text-align: center;"><code>size</code></td><td style="text-align: center;">返回int，数组<strong>元素总数</strong>，即每一维长度的乘积</td></tr><tr class="odd"><td style="text-align: center;"><code>dtype</code></td><td style="text-align: center;">返回data-type，数组<strong>成员类型</strong></td></tr><tr class="even"><td style="text-align: center;"><code>shape</code></td><td style="text-align: center;">返回 tuple，表示数组的<strong>尺寸</strong>，对于 n 行 m 列的矩阵，形状为(n,m)</td></tr><tr class="odd"><td style="text-align: center;"><code>itemsize</code></td><td style="text-align: center;">返回 int，表示数组的<strong>每个元素的大小（</strong>以字节为单位）</td></tr></tbody></table><ol start="2" type="1"><li>创建数组对象</li></ol><ul><li>创建数组并查看数组属性</li></ul><p><code>numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)  //注意是array不是ndarry</code></p><table><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>object</code></td><td style="text-align: center;">接收<strong>array</strong>，表示想要创建的数组。<em>无默认</em></td></tr><tr class="even"><td style="text-align: center;"><code>dtype</code></td><td style="text-align: center;">接收data-type，表示数组所需的数据类型。如果未给定，则选择保存对象所需的最小类型。<em>默认为None</em>。</td></tr><tr class="odd"><td style="text-align: center;"><code>ndmin</code></td><td style="text-align: center;">接收int。指定生成数组应该具有的最小维数。<em>默认为None</em></td></tr></tbody></table><ul><li><p>重新设置数组的 <code>shape</code> 属性</p><p><code>arr.shape = a,b  //总数必须不变，即不允许截断</code></p></li><li><p>使用 <code>arange</code> 函数创建数组</p><p><code>arange(begin,end,等分量)   // [begin,end)</code></p></li><li><p>使用 <code>linspace</code> 函数创建等差数组 (begin,end,num)</p><p>公差d = (end - start) / (num - 1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;b = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>)<br>[<span class="hljs-number">0.</span>    <span class="hljs-number">0.125</span> <span class="hljs-number">0.25</span>  <span class="hljs-number">0.375</span> <span class="hljs-number">0.5</span>   <span class="hljs-number">0.625</span> <span class="hljs-number">0.75</span>  <span class="hljs-number">0.875</span> <span class="hljs-number">1.</span>   ]<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>logspace</code> 函数创建<strong>等比</strong>数列</p></li><li><p><code>zeros</code>函数 全0数组</p></li><li><p><code>eye</code>函数创建<strong>单位</strong>矩阵</p></li><li><p><code>diag</code>函数创建<strong>对角</strong>矩阵</p></li><li><p><code>ones</code>函数创建<strong>全1</strong>数组</p></li></ul><h2 id="numpy-矩阵与通用函数">NumPy 矩阵与通用函数</h2><h2 id="利用-numpy-进行统计分析">利用 NumPy 进行统计分析</h2><hr><p>参考</p><ol type="1"><li><a href="https://zh.wikipedia.org/wiki/NumPy">维基百科numpy</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
